<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floor 1 - Parking Slots</title>
    <!-- Importing futuristic fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700;900&family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Root Variables (Neon/Glow colors) --- */
        :root {
            --primary-color: #00e5ff; /* Brighter Cyan/Neon Blue */
            --accent-color: #4de5ff; /* Slightly lighter neon for hover */
            --background-start: #1c265c; /* Very Dark Blue */
            --background-end: #0077b6; /* Medium Blue */
            --text-light: #f0f0f0;
            --text-dark: #0f172a;

            /* Slot Status Colors with Neon Glow */
            --status-available: #69f0ae; /* Neon Green */
            --status-reserved: #ffee58; /* Neon Yellow */
            --status-occupied: #ff1744; /* Neon Red */
        }

        /* --- Base & Background (Glassmorphism & Centering) --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif; /* Using Inter for body text */
        }

        body {
            min-height: 100vh;
            display: flex;
            justify-content: center; 
            align-items: flex-start;
            padding: 20px 10px;
            overflow-x: hidden;
            
            background: linear-gradient(135deg, var(--background-start) 0%, var(--background-end) 100%);
            color: var(--text-light);
        }

        /* Background Blurs (Aesthetic) */
        body::before, body::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            filter: blur(100px);
            z-index: 0;
        }
        body::before { top: 5%; left: 10%; width: 250px; height: 250px; background: rgba(0, 229, 255, 0.3); }
        body::after { bottom: 5%; right: 10%; width: 300px; height: 300px; background: rgba(28, 38, 92, 0.4); }

        /* --- Rectangular Box Container (Glassmorphism Wrapper) --- */
        .glass-page-wrapper {
            position: relative;
            z-index: 10;
            width: 95%;
            max-width: 1000px; /* Centering limit */
            padding: 35px 30px; /* Padding for the container box */
            border-radius: 25px;

            /* Futuristic Glassmorphism */
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(0, 229, 255, 0.2);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            margin-top: 20px; /* Space from the top */
        }

        /* --- Title Styling (Futuristic Orbitron) --- */
        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(2rem, 6vw, 2.8rem);
            margin: 0 0 35px;
            padding-bottom: 15px;
            font-weight: 700;
            text-align: center;
            color: var(--primary-color); 
            text-shadow: 0 0 15px rgba(0, 229, 255, 0.8), 0 0 5px rgba(0, 229, 255, 0.5); 
            letter-spacing: 2px;
            border-bottom: 1px solid rgba(0, 229, 255, 0.3);
        }

        /* ------------------------------------------------ */
        /* --- SLOTS GRID (Compact and Responsive) --- */
        /* ------------------------------------------------ */
        .slots-container {
            width: 100%;
            margin: 0 auto;
            display: grid;
            gap: 15px; /* Reduced gap for compactness */
            justify-content: center; 
            
            /* Fluid Grid: Aims for 3-4 columns, min width 90px per card */
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr)); 
        }

        /* --- Slot Card Styling (Smaller, Compact Panels) --- */
        .slot-card {
            height: 90px; /* Reduced card height */
            border-radius: 10px; /* Slightly reduced radius */
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            
            /* Glassmorphism */
            background: rgba(255, 255, 255, 0.08); 
            border: 1px solid rgba(255, 255, 255, 0.15); 
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); 
            
            /* Content Centering */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 8px; /* Reduced padding */
            color: var(--text-light); 
            user-select: none;
        }

        .slot-card h3 {
            font-size: clamp(0.9rem, 3vw, 1.2rem); /* Smaller font for slot name */
            font-family: 'Orbitron', sans-serif; 
            color: var(--text-light);
            text-shadow: 0 0 5px var(--primary-color); 
            line-height: 1.1;
            margin-bottom: 2px;
        }

        .slot-card p {
            font-size: clamp(0.55rem, 1.5vw, 0.75rem); /* Smaller status text */
            font-weight: 400;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-icon {
            font-size: 1.1rem; /* Smaller icon */
            margin-bottom: 2px;
            text-shadow: 0 0 8px currentColor; 
        }

        /* --- Status Colors & Interaction (Neon Glow) --- */

        /* Available - Highlighting Interactivity */
        .slot-available {
            background: var(--status-available); 
            color: var(--text-dark); 
            border: 1px solid var(--status-available);
            box-shadow: 0 0 10px 2px var(--status-available); /* Reduced shadow intensity */
            animation: pulseGlow 1.5s infinite alternate; 
            cursor: pointer;
        }

        .slot-available:hover {
            background: var(--accent-color); 
            border-color: var(--primary-color);
            transform: scale(1.05);
            box-shadow: 0 0 20px 4px var(--primary-color); 
            animation: none; 
        }

        /* Reserved/Occupied */
        .slot-reserved {
            background: var(--status-reserved);
            color: var(--text-dark);
            border: 1px solid var(--status-reserved);
            box-shadow: 0 0 8px 1px var(--status-reserved);
            opacity: 0.85;
        }
        .slot-occupied {
            background: var(--status-occupied);
            color: var(--text-light);
            border: 1px solid var(--status-occupied);
            box-shadow: 0 0 8px 1px var(--status-occupied);
            opacity: 0.7;
        }

        .slot-reserved:hover, .slot-occupied:hover {
            transform: none;
            cursor: not-allowed;
        }

        /* Countdown display */
        .countdown {
            font-size: 0.7rem;
            font-weight: 700;
            margin-top: 2px;
            color: var(--text-dark);
        }

        /* --- Keyframe Animation for Available Slot Pulse --- */
        @keyframes pulseGlow {
            0% {
                box-shadow: 0 0 8px 2px var(--status-available);
            }
            100% {
                box-shadow: 0 0 16px 4px var(--status-available);
            }
        }


        /* ------------------------------------------------ */
        /* --- Modal Styling (Replacing confirm/alert) --- */
        /* ------------------------------------------------ */
         /* Adjusted modal styles for better aesthetic */
        #custom-confirm-modal {
            transition: opacity 0.3s ease;
        }

        #custom-confirm-modal > div {
            animation: popIn 0.3s ease-out;
            background: #0d122b; /* Darker background */
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 30px var(--primary-color);
            color: var(--text-light);
            max-width: 90%;
            min-width: 280px;
            text-align: center;
            border: 2px solid var(--primary-color);
        }

        #custom-confirm-modal button {
            transition: background-color 0.2s, transform 0.1s;
        }
        #custom-confirm-modal #confirm-yes { background: #1de9b6; color: var(--text-dark); }
        #custom-confirm-modal #confirm-yes:hover { background: #00e676; transform: translateY(-1px); }
        #custom-confirm-modal #confirm-no { background: #ff5252; color: white; }
        #custom-confirm-modal #confirm-no:hover { background: #ff1744; transform: translateY(-1px); }

        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.9); }
            100% { opacity: 1; transform: scale(1); }
        }

        /* Mobile specific adjustments */
        @media (max-width: 600px) {
            .title {
                font-size: 1.6rem;
                margin-bottom: 25px;
            }
            .glass-page-wrapper {
                padding: 20px 15px;
            }
        }
    </style>
</head>
<body>
<div class="glass-page-wrapper">
    <h1 class="title">Floor 1 - Select Your Parking Slot üöó</h1>
    <div id="slotsContainer" class="slots-container"></div>
</div>

<script type="module">
// ---------------- CUSTOM MODAL/MESSAGE UI (Replacing alert/confirm) ----------------
// Function to show a temporary message (replaces alert)
function showMessage(message, type = 'info') {
    const box = document.createElement('div');
    box.textContent = message;
    box.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 12px 20px;
        border-radius: 8px;
        z-index: 10000;
        font-weight: 600;
        color: var(--text-dark);
        background-color: ${type === 'error' ? '#ff1744' : '#00e5ff'};
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        transition: all 0.5s ease-in-out;
        opacity: 0;
        font-family: 'Inter', sans-serif;
    `;
    document.body.appendChild(box);

    setTimeout(() => {
        box.style.opacity = 1;
    }, 10);
    
    setTimeout(() => {
        box.style.opacity = 0;
        box.addEventListener('transitionend', () => box.remove());
    }, 3000);
}

// Function to handle confirmation (replaces confirm)
function showConfirmModal(message) {
    return new Promise(resolve => {
        const modalId = 'custom-confirm-modal';
        let modal = document.getElementById(modalId);
        if (modal) modal.remove();

        modal = document.createElement('div');
        modal.id = modalId;
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20000;
            backdrop-filter: blur(8px);
        `;

        const content = document.createElement('div');
        content.style.cssText = `
            background: #0d122b;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 30px var(--primary-color);
            color: var(--text-light);
            max-width: 90%;
            min-width: 280px;
            text-align: center;
            border: 2px solid var(--primary-color);
            font-family: 'Inter', sans-serif;
        `;
        content.innerHTML = `
            <p style="font-size: 1.1rem; margin-bottom: 25px; line-height: 1.5;">${message}</p>
            <button id="confirm-yes" style="padding: 10px 20px; margin: 0 8px; background: #1de9b6; color: var(--text-dark); border: none; border-radius: 8px; cursor: pointer; font-weight: 700; transition: all 0.2s;">Yes</button>
            <button id="confirm-no" style="padding: 10px 20px; margin: 0 8px; background: #ff5252; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 700; transition: all 0.2s;">No</button>
        `;

        modal.appendChild(content);
        document.body.appendChild(modal);

        document.getElementById('confirm-yes').onclick = () => {
            modal.remove();
            resolve(true);
        };
        document.getElementById('confirm-no').onclick = () => {
            modal.remove();
            resolve(false);
        };
    });
}
// ---------------- END CUSTOM MODAL/MESSAGE UI ----------------

console.log("Floor1.js loaded!");

// ---------------- FIREBASE IMPORTS ----------------
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
import { getDatabase, ref, update, push, set, serverTimestamp, onValue } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js";

// ---------------- FIREBASE CONFIG ----------------
// NOTE: Using provided static config/keys as no Canvas global variables were provided
const firebaseConfig = {
    apiKey: "AIzaSyDWoFHHXKxEMBk-ZhZgYstPV6fylL8SLiE",
    authDomain: "parkifycapstone.firebaseapp.com",
    databaseURL: "https://parkifycapstone-default-rtdb.asia-southeast1.firebasedatabase.app/",
    projectId: "parkifycapstone",
    storageBucket: "parkifycapstone.firebasestorage.app",
    messagingSenderId: "578453779700",
    appId: "1:578453779700:web:c34c4202c53b2152bc1aa1",
    measurementId: "G-5NCE2MM3PM"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// ---------------- DOM & USER INFO ----------------
const slotsContainer = document.getElementById("slotsContainer");
const FLOOR_NAME = "Floor1";
const userID = localStorage.getItem("userID");
const userName = localStorage.getItem("userName") || "Parkify User";

// ---------------- TRACK AUTO-RELEASE TIMERS ----------------
const reservationTimers = {}; // slotId -> timeout for DB update (10s)
const countdownIntervals = {}; // slotId -> interval for countdown display (1s)

// ---------------- REAL-TIME SLOT LISTENER (FIXED FOR LIVE COUNTDOWN) ----------------
const slotsRef = ref(db, `parkingSlots/parkingSlots/${FLOOR_NAME}/slots`);
onValue(slotsRef, snapshot => {
    const slotsData = snapshot.val() || {};
    
    // Get current IDs in the DOM to check for deletions later
    const existingSlotIds = new Set(Array.from(slotsContainer.children).map(child => child.id.replace('slot-', '')));
    const newSlotIds = new Set(Object.keys(slotsData));

    // 1. Process/Update existing slots and create new ones
    Object.keys(slotsData).forEach(slotId => {
        const slot = slotsData[slotId];
        let status = (slot.status || "unknown").toLowerCase();
        let card = document.getElementById(`slot-${slotId}`);

        let statusClass = "", iconHtml = "", countdownHtml = "";
        let mustReRenderContent = false;

        // --- Status Logic and Timer Management ---
        if (status === "available") {
            statusClass = "slot-available";
            iconHtml = "‚úÖ";
            // Clear any running timers/intervals if it becomes available
            if (reservationTimers[slotId]) {
                clearTimeout(reservationTimers[slotId]);
                delete reservationTimers[slotId];
            }
            if (countdownIntervals[slotId]) {
                clearInterval(countdownIntervals[slotId]);
                delete countdownIntervals[slotId];
            }
            mustReRenderContent = true;

        } else if (status === "reserved") {
            statusClass = "slot-reserved";
            iconHtml = "‚è≥";
            
            // Check if client-side timer needs to be initialized/re-initialized
            if (!countdownIntervals[slotId]) {
                // Timer is NOT running, so start fresh (or restarted)
                mustReRenderContent = true; 
                let remaining = 10;
                countdownHtml = `<span class="countdown">${remaining}s</span>`;
                
                // 1. Setup the Auto-Release Timeout (DB update) - Retains original logic
                reservationTimers[slotId] = setTimeout(async () => {
                    try {
                        await update(ref(db, `parkingSlots/parkingSlots/${FLOOR_NAME}/slots/${slotId}`), { 
                            status: "available", 
                            lastUpdated: serverTimestamp() 
                        });
                        await logAction("slot_auto_released", `${slot.slotName || slotId} auto-released after 10s`);
                    } catch (err) {
                        console.error("Auto-release error:", err);
                    } finally {
                        if (countdownIntervals[slotId]) clearInterval(countdownIntervals[slotId]);
                        delete reservationTimers[slotId];
                        delete countdownIntervals[slotId];
                    }
                }, 10000);

                // 2. Setup the Countdown Display Interval (Client-side display) - Retains original logic
                countdownIntervals[slotId] = setInterval(() => {
                    remaining--;
                    // Find the countdown span in the DOM
                    const countdownElem = document.querySelector(`#slot-${slotId} .countdown`);
                    if (countdownElem) countdownElem.textContent = remaining + "s";
                    if (remaining <= 0) {
                        clearInterval(countdownIntervals[slotId]);
                        delete countdownIntervals[slotId];
                    }
                }, 1000);

            } else {
                // Timer IS running. Do NOT re-render the inner HTML. 
                // Just ensure the countdown span container exists (it should, if the card exists).
                countdownHtml = '<span class="countdown"></span>'; 
            }

        } else if (status === "occupied") {
            statusClass = "slot-occupied";
            iconHtml = "‚ùå";
             // Clear any running timers/intervals if it becomes occupied
            if (reservationTimers[slotId]) {
                clearTimeout(reservationTimers[slotId]);
                delete reservationTimers[slotId];
            }
            if (countdownIntervals[slotId]) {
                clearInterval(countdownIntervals[slotId]);
                delete countdownIntervals[slotId];
            }
            mustReRenderContent = true;
        }

        // --- DOM Update Logic (Intelligent Re-rendering) ---
        const newContent = `
            <h3>${slot.slotName || slotId}</h3>
            <span class="status-icon">${iconHtml}</span>
            <p>${status.toUpperCase()}</p>
            ${countdownHtml}
        `;

        if (!card) {
            // Create New Card if it doesn't exist
            card = document.createElement("div");
            card.id = `slot-${slotId}`;
            card.classList.add("slot-card");
            slotsContainer.appendChild(card);
            mustReRenderContent = true; // Ensure new card gets content
        } 
        
        // Always update class for color change
        card.className = "slot-card " + statusClass;
        
        // Only set innerHTML if content needs to change (i.e., status changed, or it's a new card)
        // This prevents interrupting the countdown span's innerHTML update
        if (mustReRenderContent) {
             card.innerHTML = newContent;
        }

        // Add/Re-add Event Listener (crucial for proper garbage collection/memory management)
        const oldListener = card.listener;
        if (oldListener) card.removeEventListener("click", oldListener); 

        if (status === "available") {
            card.style.cursor = "pointer";
            const newListener = () => reserveSlot(slotId, slot.slotName || slotId);
            card.addEventListener("click", newListener);
            card.listener = newListener; // Store reference to remove later
        } else {
            card.style.cursor = "not-allowed";
        }
    });

    // 2. Remove slots that no longer exist in the data
    existingSlotIds.forEach(slotId => {
        if (!newSlotIds.has(slotId)) {
            const cardToRemove = document.getElementById(`slot-${slotId}`);
            if (cardToRemove) {
                cardToRemove.remove();
                // Clear related timers for removed slots (safety)
                if (reservationTimers[slotId]) clearTimeout(reservationTimers[slotId]);
                if (countdownIntervals[slotId]) clearInterval(countdownIntervals[slotId]);
                delete reservationTimers[slotId];
                delete countdownIntervals[slotId];
            }
        }
    });
});

// ---------------- RESERVE SLOT ----------------
async function reserveSlot(slotId, slotName) {
    const isConfirmed = await showConfirmModal(`Reserve ${slotName} for ${userName}?`);
    if (!isConfirmed) return;

    const slotRef = ref(db, `parkingSlots/parkingSlots/${FLOOR_NAME}/slots/${slotId}`);
    const userRef = userID ? ref(db, `users/users/${userID}`) : null;

    try {
        await update(slotRef, {
            status: "reserved",
            userID: userID || "TEMP_USER_" + Date.now(),
            userName,
            reservedAt: serverTimestamp(),
            lastUpdated: serverTimestamp()
        });

        if (userRef) await update(userRef, { selectedFloor: FLOOR_NAME, selectedSlot: slotName, lastReservation: serverTimestamp() });

        await logAction("slot_reserved", `${userName} reserved ${slotName}`);
    } catch (err) {
        console.error("Reservation error:", err);
        showMessage("Failed to reserve slot. It may have been taken.", "error");
    }
}

// ---------------- LOG HELPER ----------------
async function logAction(action, details) {
    const logsRef = ref(db, "logs/logs");
    const newLogRef = push(logsRef);
    await set(newLogRef, { action, details, timestamp: serverTimestamp(), userID: userID || "SYSTEM" });
}
</script>
</body>
</html>